{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/IndexToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IUniswapV2Router/IUniswapV2Router.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ncontract IndexTokenNew is IERC20 {\r\n    using SafeMath for uint256;\r\n    uint public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n\r\n    //Index token constants\r\n    address immutable owner;\r\n    address[] public holders;\r\n\r\n    address[] public tokens;\r\n    uint[] public percentages;\r\n\r\n    address uniswapAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D ;\r\n    IUniswapV2Router02 uniswap = IUniswapV2Router02(uniswapAddress);\r\n    address wMATICAddr = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\r\n\r\n\r\n    constructor(address _owner, address[] memory _tokens, uint[] memory  _percentages, string memory _name, string memory _symbol) {\r\n        //check percentages\r\n        uint numOfTokens = _percentages.length;\r\n        uint percentageCounter;\r\n        uint _decimalFactor = 10**16;\r\n\r\n        for(uint i; i < numOfTokens; i++) {\r\n            percentageCounter += _percentages[i];\r\n        }\r\n\r\n        //multiply to correct decimals\r\n        for(uint i; i < numOfTokens; i++){\r\n            _percentages[i] = _percentages[i] * _decimalFactor;\r\n        }\r\n\r\n        require(percentageCounter <= 100, \"percentages do not add up to 100\");\r\n        owner = _owner;\r\n        tokens = _tokens;\r\n        percentages = _percentages;\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n\r\n\r\n    }\r\n\r\n    function getMinToken(uint token,uint amount) public view returns (uint256 result){\r\n        uint _decimalFactor = 10**18;\r\n        uint percentage = percentages[token];\r\n        result = percentage.mul(amount).div(_decimalFactor);\r\n    }\r\n\r\n    //Index token mint\r\n    function mint(uint amount) public {\r\n        //get number of tokens using length\r\n        uint numOfTokens = tokens.length;\r\n    \r\n        //loop through all tokens\r\n        for(uint i; i < numOfTokens; i++){\r\n            address _token = tokens[i];\r\n\r\n            uint transferAmount = getMinToken(i, amount);\r\n            bool success = IERC20(_token).transferFrom(tx.origin,address(this), transferAmount);\r\n            require(success, \"transfer failed\");\r\n        }\r\n        //add to holders array\r\n        holders.push(tx.origin);\r\n\r\n        _mint(amount);\r\n    }\r\n\r\n\r\n\r\n    function redeem(uint amount) public {\r\n        //get number of tokens using length\r\n        require(amount <= balanceOf[tx.origin] );\r\n\r\n        uint numOfTokens = tokens.length;\r\n        address[] memory _tokens = tokens;\r\n\r\n        //loop through all tokens\r\n        for (uint i; i < numOfTokens; i++) {\r\n            address _token = _tokens[i];\r\n\r\n            uint transferAmount = getMinToken(i, amount);\r\n            IERC20(_token).approve(tx.origin, transferAmount);\r\n            bool success = IERC20(_token).transfer(tx.origin, transferAmount);\r\n            require(success, \"transfer failed\");\r\n        }\r\n\r\n        burn(tx.origin,amount); \r\n    }\r\n\r\n\r\n    //owner withdraw streaming fee\r\n    function streamingFee() public  {\r\n        require(tx.origin == owner, \"Not owner!\");\r\n\r\n        address[] memory _holders = holders;\r\n\r\n        uint feeCounter;\r\n     \r\n\r\n\r\n    // REMOVE DUPLICATE HOLDERS IN ARRAY\r\n    // use nested for loop to find the duplicate elements in array \r\n    uint x;\r\n    uint y;\r\n    uint z;\r\n    uint size = holders.length;\r\n    for ( x = 0; x < size; x ++)  \r\n    {  \r\n        for ( y = x + 1; y < size; y++)  \r\n        {  \r\n            // use if statement to check duplicate element  \r\n            if ( _holders[x] == _holders[y])  \r\n            {  \r\n                // delete the current position of the duplicate element  \r\n                for ( z = y; z < size - 1; z++)  \r\n                {  \r\n                    _holders[z] = _holders[z + 1];  \r\n                }  \r\n                // decrease the size of array after removing duplicate element  \r\n                size--;  \r\n                  \r\n            // if the position of the elements is changes, don't increase the index j  \r\n                y--;      \r\n            }  \r\n        }  \r\n    }\r\n\r\n        //rebase / reduce supply by 1%\r\n        uint numHolders = _holders.length;\r\n        for (uint i; i < numHolders; i++){\r\n            if (balanceOf[_holders[i]] > 0){\r\n            uint amtToBurn = (balanceOf[_holders[i]]) / 99;\r\n            \r\n            burn(_holders[i], amtToBurn);\r\n            feeCounter += amtToBurn;\r\n            }\r\n        }\r\n\r\n        _mint(feeCounter);\r\n\r\n    \r\n    }\r\n\r\n    function rebalancePercentages() public {  \r\n        require(tx.origin == owner); \r\n        uint numOfTokens = tokens.length;\r\n\r\n        uint total;\r\n        uint _decimalFactor = 10**18;\r\n\r\n        //find balance of all tokens\r\n        for (uint i; i < numOfTokens; i++) {\r\n\r\n            total += IERC20(tokens[i]).balanceOf(address(this));\r\n\r\n        }\r\n\r\n        //change percentage values in storage\r\n        for (uint i; i < numOfTokens; i++) {\r\n            percentages[i] = IERC20(tokens[i]).balanceOf(address(this)) * _decimalFactor / total;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    function rebalance(uint tokenOut, uint tokenIn, uint _amount) public {\r\n        address[] memory path = new address[](2);\r\n        //path[0] = tokens[tokenOut]; \r\n        //path[1] = tokens[tokenIn];\r\n        //better rates:\r\n        path[0] = tokens[tokenOut];\r\n        path[1] = wMATICAddr; \r\n        path[1] = tokens[tokenIn];\r\n\r\n        \r\n        IERC20(tokens[tokenOut]).approve(uniswapAddress,_amount);\r\n\r\n        uniswap.swapExactTokensForTokens(_amount, 0, path, address(this), block.timestamp + 15);\r\n\r\n        rebalancePercentages();\r\n        \r\n    }\r\n\r\n    function getName() public view returns (string memory) {\r\n        return name;\r\n    }\r\n\r\n    function getSymbol() public view returns (string memory) {\r\n        return symbol;\r\n    }\r\n\r\n    function getPercentages(uint i) public view returns (uint) {\r\n        return percentages[i];\r\n    }\r\n\r\n\r\n    function getTotalSupply() public view returns (uint256){\r\n        return totalSupply;\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool) {\r\n        balanceOf[tx.origin] -= amount;\r\n        balanceOf[recipient] += amount;\r\n\r\n        //add to holders array\r\n        holders.push(recipient);\r\n\r\n        emit Transfer(tx.origin, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        allowance[tx.origin][spender] = amount;\r\n        emit Approval(tx.origin, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool) {\r\n        allowance[sender][tx.origin] -= amount;\r\n        balanceOf[sender] -= amount;\r\n        balanceOf[recipient] += amount;\r\n\r\n\r\n        //add to holders array\r\n        holders.push(recipient);\r\n\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _mint(uint amount) internal {\r\n        balanceOf[tx.origin] += amount;\r\n        totalSupply += amount;\r\n\r\n        emit Transfer(address(0), tx.origin, amount);\r\n    }\r\n\r\n    function burn(address burnee, uint amount) internal {\r\n        balanceOf[burnee] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(tx.origin, address(0), amount);\r\n    }\r\n\r\n\r\n    //some getter helpers\r\n    function getTokens() public view returns (address[] memory){\r\n        return tokens;\r\n    }\r\n\r\n    function getSingleToken(uint _index) public view returns (address) {\r\n        return tokens[_index];\r\n    }\r\n\r\n    function getAllPercentages() public view returns (uint[] memory) {\r\n        return percentages;\r\n    }\r\n\r\n    function getSinglePercentage(uint _index) public view returns (uint) {\r\n        return percentages[_index];\r\n    }\r\n\r\n    function getNumOfTokens() public view returns (uint) {\r\n        return tokens.length;\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}"
    },
    "contracts/interfaces/IUniswapV2Router/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    \r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}"
    },
    "contracts/mintAllTestTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n\r\ncontract mintAllTestTokens {\r\n    address USDCAddress = 0x73778d5569E3798360C0F557CeB549092759A029;\r\n    address WETHAddress = 0x31bF40f5642BCC6d41f28cccB2ADFB735722Bb30;\r\n    address WBTCAddress = 0x7FA0D30b30aF032bd1d8453603D7Df948021eA60;\r\n    address WFTMAddress = 0xeF35e201aaBEFe47Ff3e01c87ef6D35878588B0C;\r\n    address AAVEAddress = 0x415cE4e20bD34F9620a926db1B6a9ca08424FCdb;\r\n\r\n    function mintAllTokens() public {\r\n        genericToken(USDCAddress).mint(1000 ether);\r\n        genericToken(WETHAddress).mint(1000 ether);\r\n        genericToken(WBTCAddress).mint(1000 ether);\r\n        genericToken(WFTMAddress).mint(1000 ether);\r\n        genericToken(AAVEAddress).mint(1000 ether);\r\n\r\n        genericToken(USDCAddress).approve(msg.sender,1000 ether);\r\n        genericToken(WETHAddress).approve(msg.sender,1000 ether);\r\n        genericToken(WBTCAddress).approve(msg.sender,1000 ether);\r\n        genericToken(WFTMAddress).approve(msg.sender,1000 ether);\r\n        genericToken(AAVEAddress).approve(msg.sender,1000 ether);\r\n\r\n        genericToken(USDCAddress).transferFrom(address(this),msg.sender,1000);\r\n        /*genericToken(WETHAddress).transferFrom(address(this),msg.sender,1000 ether);\r\n        genericToken(WBTCAddress).transferFrom(address(this),msg.sender,1000 ether);\r\n        genericToken(WFTMAddress).transferFrom(address(this),msg.sender,1000 ether);\r\n        genericToken(AAVEAddress).transferFrom(address(this),msg.sender,1000 ether);*/\r\n\r\n                \r\n    }\r\n    \r\n\r\n}   \r\n\r\ninterface genericToken {\r\n    function mint(uint amount) external;\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n}"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IERC20.sol\";\r\n\r\ncontract Token is IERC20 {\r\n    uint public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n    string public name ;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n\r\n    constructor(string memory _name,string memory _symbol){\r\n        name=_name;\r\n        symbol=_symbol;\r\n    }\r\n    function transfer(address recipient, uint amount) external returns (bool) {\r\n        \r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[recipient] += amount;\r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool) {\r\n        allowance[sender][msg.sender] -= amount;\r\n        balanceOf[sender] -= amount;\r\n        balanceOf[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function mint(uint amount) external {\r\n        balanceOf[msg.sender] += amount;\r\n        totalSupply += amount;\r\n        emit Transfer(address(0), msg.sender, amount);\r\n    }\r\n\r\n    function burn(uint amount) external {\r\n        balanceOf[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n}"
    },
    "contracts/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./IndexToken.sol\";\r\n\r\ncontract TokenFactory {\r\n\r\n    mapping(address => mapping(uint => address)) public addressToTokens;\r\n    mapping(address => uint) tokenCount;\r\n\r\n    //STATE CHANGES\r\n\r\n    function createToken(address[] memory _tokens, uint[] memory  _percentages, string memory _name, string memory _symbol) public {\r\n\r\n        //create new index token\r\n        IndexTokenNew newToken = new IndexTokenNew(msg.sender, _tokens, _percentages, _name, _symbol);\r\n        ++tokenCount[msg.sender];\r\n        //map msg.sender's tokenCounter to new token to msg.sender\r\n        addressToTokens[msg.sender][tokenCount[msg.sender]] = address(newToken);   \r\n    }\r\n\r\n    /// @notice mint/issue tokens in existing Index Token\r\n    /// @param _tokenAddress = address of Index Token\r\n    /// @param amount = amount of tokens to issue\r\n    function issueToken(address _tokenAddress, uint amount) public {\r\n        IndexTokenNew(_tokenAddress).mint(amount);\r\n    }\r\n\r\n    /// @notice redeem token, burn index token, receive underlying assets\r\n    /// @param _tokenAddress = address of Index Token\r\n    /// @param amount = amount of Index Token to burn\r\n    function redeemToken(address _tokenAddress, uint amount) public {\r\n        IndexTokenNew(_tokenAddress).redeem(amount);\r\n    }\r\n\r\n    /// @notice rebalance, maybe give index of underlying asset to sell,receieve, and amount of token sold\r\n    /// @param _tokenAddress = address of index token\r\n    /// @param _underlyingSell = index of index token's underlying assets array to sell\r\n    /// @param _underlyingBuy = index of index token's underlying assets array to buy\r\n    /// @param _amtToSell = amount of underlying token to sell\r\n    function rebalance(address _tokenAddress, uint _underlyingSell, uint _underlyingBuy, uint _amtToSell) public {\r\n        IndexTokenNew(_tokenAddress).rebalance(_underlyingSell, _underlyingBuy, _amtToSell);\r\n    }\r\n\r\n    /// @notice sends 1% of all index tokens to token creator\r\n    /// @param _indexAddress = index token to withdraw from, requires msg.sender is owner\r\n    function collectFee(address _indexAddress) public {\r\n        IndexTokenNew(_indexAddress).streamingFee();\r\n    }\r\n\r\n    //GETTERS\r\n\r\n    /// @notice returns the amount of index tokens a user has created\r\n    /// @param _creator = address of user\r\n    function getAmountOfIndexTokens(address _creator) public view returns (uint) {\r\n        return tokenCount[_creator];\r\n    }\r\n\r\n    /// @notice return array of tokens per address\r\n    /// @param _creator = address of user\r\n    function getAllTokenAddresses(address _creator) public view returns (address[] memory) {\r\n        uint numTokens = tokenCount[_creator];\r\n        address[] memory tokenAddresses = new address[](numTokens); \r\n        for(uint i = 0; i < numTokens; i++ ) {\r\n            tokenAddresses[i] = addressToTokens[_creator][i+1];  \r\n        }\r\n        return tokenAddresses;\r\n    }\r\n\r\n    /// @notice Same as above, but returns address of a single index token by entering owner address, and index of the token\r\n    /// @param  _creator = address of user\r\n    /// @param  index = index of user's created Index token\r\n    function getSingleTokenAddress(address _creator, uint index) public view returns (address) {\r\n        return addressToTokens[_creator][index];\r\n    }\r\n\r\n    /// @notice get array of all underlying assets of an index token\r\n    /// @param _indexAddress = address of index token\r\n    function getAllUnderlying(address _indexAddress) public view returns (address[] memory) {\r\n        return IndexTokenNew(_indexAddress).getTokens();\r\n    }\r\n\r\n    /// @notice Same as above, but returns address of a single underlying token of a index token\r\n    /// @param _indexAddress = address of index token\r\n    /// @param underlyingIndex = index of Index token's array of underlying assets\r\n    function getSingleUnderlying(address _indexAddress, uint underlyingIndex) public view returns (address) {\r\n        return IndexTokenNew(_indexAddress).getSingleToken(underlyingIndex);\r\n    }\r\n\r\n    /// @notice get array of all percentages for a token\r\n    /// @param _indexAddress = address of index token\r\n    function getAllPercentages(address _indexAddress) public view returns (uint[] memory) {\r\n        return IndexTokenNew(_indexAddress).getAllPercentages();\r\n    }\r\n\r\n    /// @notice same as above, but get percentage for a specific underlying asset\r\n    /// @param _indexAddress = address of index token\r\n    /// @param underlyingIndex = index of index token's underlying assets array\r\n    function getSinglePercentage(address _indexAddress, uint underlyingIndex) public view returns (uint) {\r\n        return IndexTokenNew(_indexAddress).getSinglePercentage(underlyingIndex);\r\n    }\r\n\r\n    /// @notice return array of all token balances in an index\r\n    /// @param _indexAddress = address of index token\r\n    function getAllAmounts(address _indexAddress) public view returns (uint[] memory) {\r\n        uint numOfTokens = IndexTokenNew(_indexAddress).getNumOfTokens();\r\n        uint[] memory tokenAmounts = new uint[](numOfTokens); \r\n        for(uint i; i < numOfTokens; i++ ) {\r\n            uint tokenAmount = getSingleAmount(_indexAddress, i);\r\n            tokenAmounts[i] = tokenAmount;\r\n        }\r\n        return tokenAmounts;\r\n        \r\n    }\r\n\r\n\r\n    /// @notice get balance of a single token balance in an index\r\n    /// @param _indexAddress = address of index token\r\n    /// @param underlyingIndex = index of Index token's underlying assets array\r\n    function getSingleAmount(address _indexAddress, uint underlyingIndex) public view returns (uint) {\r\n        address underlyingToken = getSingleUnderlying(_indexAddress, underlyingIndex);\r\n        return IERC20(underlyingToken).balanceOf(_indexAddress);\r\n    }\r\n\r\n    function getName(address _indexAddress) public view returns (string memory) {\r\n        return IndexTokenNew(_indexAddress).getName();\r\n    }\r\n\r\n    function getSymbol(address _indexAddress) public view returns (string memory) {\r\n        return IndexTokenNew(_indexAddress).getSymbol();\r\n    }\r\n\r\n    function getAllNames(address _creator) public view returns (string[] memory) {\r\n        uint numTokens = getAmountOfIndexTokens(_creator);\r\n        string[] memory tokenNames = new string[](numTokens);\r\n        for(uint i; i < numTokens; i++) {\r\n            tokenNames[i] = getName(addressToTokens[_creator][i+1]);\r\n        }\r\n        return tokenNames;\r\n    }\r\n\r\n    function getAllSymbols(address _creator) public view returns (string[] memory) {\r\n        uint numTokens = getAmountOfIndexTokens(_creator); //number of tokens a user has created\r\n        string[] memory tokenSymbols = new string[](numTokens);   //memory array to store all symbols temporarily\r\n        for(uint i; i < numTokens; i++) {\r\n            tokenSymbols[i] = getSymbol(addressToTokens[_creator][i+1]); //assign \r\n        }\r\n        \r\n        return tokenSymbols;\r\n    }\r\n\r\n    \r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}